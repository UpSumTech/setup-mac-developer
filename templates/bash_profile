########## Not generated by bash-it #############

[ -f ~/.bashrc ] && . ~/.bashrc
export VISUAL=vim
export EDITOR=$VISUAL
export GIT_EDITOR=$EDITOR
export HISTSIZE=30000
export HISTFILESIZE=$HISTSIZE
shopt -s histappend

[[ -d "$HOME/.secrets" ]] && for file in $(find "$HOME/.secrets" -type f -name "*.sh"); do . "$file"; done
[[ -f "$HOME/.activate_profile.sh" ]] && . "$HOME/.activate_profile.sh"

# Aliases for brew
alias bci='brew cask install --appdir=$BREW_APP_INSTALL_DIR'

# Init env specific prog langs and also load it in the paths properly
export PATH="$HOME/bin:$PATH"
export PATH="$(brew --prefix)/opt/docker@1.11/bin:$(brew --prefix)/opt/coreutils/libexec/gnubin:$(brew --prefix)/opt/findutils/libexec/gnubin:$(brew --prefix)/opt/gnu-tar/libexec/gnubin:$(brew --prefix)/opt/gnu-sed/libexec/gnubin:$(brew --prefix)/opt/sqlite/bin:$(brew --prefix)/opt/curl/bin:$(brew --prefix)/bin:$(brew --prefix)/sbin:$(brew --prefix)/opt:$(brew --prefix)/share:$PATH"
export PATH="$(brew --prefix)/opt/postgresql@10/bin:$PATH"
export MANPATH="$(brew --prefix)/opt/coreutils/libexec/gnuman:$(brew --prefix)/opt/findutils/libexec/gnuman:$(brew --prefix)/opt/gnu-tar/libexec/gnuman:$(brew --prefix)/opt/gnu-sed/libexec/gnuman:$MANPATH"
echo '[[ -f $(brew --prefix)/opt/autoenv/activate.sh ]] && . $(brew --prefix)/opt/autoenv/activate.sh' >> $HOME/.bash_profile
if which pyenv-virtualenv-init > /dev/null; then eval "$(pyenv init -)" && eval "$(pyenv virtualenv-init -)"; fi
[[ -x $(brew --prefix)/bin/nvm ]] || ln -s "$(brew --prefix)/opt/nvm" "$(brew --prefix)/bin/nvm"
mkdir -p $HOME/.nvm
export NVM_DIR="$HOME/.nvm"
. "$(brew --prefix)/opt/nvm/nvm.sh"
eval "$(rbenv init -)"
export PATH="$HOME/.jenv/bin:$PATH"
eval "$(jenv init -)"
eval "$(goenv init -)"
export PATH="$HOME/go/bin:$PATH"
export PATH="$HOME/.kopsenv/bin:$PATH"
export PGDATA="$HOME/var/data/postgres"
command -v pipenv >/dev/null 2>&1 && eval "$(pipenv --completion)"

# Load bash completions for homebrew packages
for completion_file in $(brew --prefix)/etc/bash_completion.d/*; do [[ -f "$completion_file" ]] && . "$completion_file"; done

# kubectl completion functionality
if command -v kubectl >/dev/null 2>&1 && test ! -f "$HOME/.kubectl-completion"; then
  kubectl completion bash > $HOME/.kubectl-completion
fi
if [[ -f "$HOME/.kubectl-completion" ]]; then
  . "$HOME/.kubectl-completion"
  type -t __ltrim_colon_completions | grep -i function >/dev/null 2>&1 || __ltrim_colon_completions() { :; }
fi

# oc completion functionality
if command -v oc >/dev/null 2>&1 && test ! -f "$HOME/.oc-completion"; then
  oc completion bash > $HOME/.oc-completion
fi
if [[ -f "$HOME/.oc-completion" ]]; then
  . "$HOME/.oc-completion"
fi
if [[ -f "$HOME/.openshift/bash_autocomplete" ]]; then
  . "$HOME/.openshift/bash_autocomplete"
fi

# ark completion functionality
if command -v ark >/dev/null 2>&1 && test ! -f "$HOME/.ark-completion"; then
  ark completion bash > $HOME/.ark-completion
fi
if [[ -f "$HOME/.ark-completion" ]]; then
  . "$HOME/.ark-completion"
fi

# kops completion functionality
if command -v kops >/dev/null 2>&1 && test ! -f "$HOME/.kops-completion"; then
  kops completion bash > $HOME/.kops-completion
fi
if [[ -f "$HOME/.kops-completion" ]]; then
  . "$HOME/.kops-completion"
fi

# source bash_utils
if [[ -f ~/.bash_utils.sh ]]; then . ~/.bash_utils.sh; fi
